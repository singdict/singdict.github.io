import {
  writable
} from "./chunk-JQBJKKUJ.js";
import "./chunk-X7HCJ7ZS.js";
import {
  onMount,
  tick
} from "./chunk-YHIUKQUI.js";
import "./chunk-5UFCALFR.js";
import "./chunk-2B2CG5KL.js";

// node_modules/@svelteuidev/composables/dist/actions/use-click-outside/use-click-outside.js
function clickoutside(node, params) {
  const { enabled: initialEnabled, callback } = params;
  const handleOutsideClick = ({ target }) => {
    if (!node.contains(target))
      callback(node);
  };
  function update({ enabled }) {
    if (enabled) {
      window.addEventListener("click", handleOutsideClick);
    } else {
      window.removeEventListener("click", handleOutsideClick);
    }
  }
  update({ enabled: initialEnabled });
  return {
    update,
    destroy() {
      window.removeEventListener("click", handleOutsideClick);
    }
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-clipboard/use-clipboard.js
function clipboard(node, text) {
  const click = async () => {
    const detailText = typeof text === "function" ? text() : text;
    if (detailText)
      try {
        await navigator.clipboard.writeText(detailText);
        node.dispatchEvent(new CustomEvent("useclipboard", { detail: detailText }));
      } catch (e) {
        node.dispatchEvent(new CustomEvent("useclipboard-error", { detail: e }));
      }
  };
  node.addEventListener("click", click, true);
  return {
    update: (t) => text = t,
    destroy: () => node.removeEventListener("click", click, true)
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-css-variable/use-css-variable.js
function cssvariable(node, props) {
  Object.entries(props).forEach(([key, value]) => {
    node.style.setProperty(`--${key}`, `${value}`);
  });
  return {
    update(_props) {
      Object.entries(_props).forEach(([key, value]) => {
        node.style.setProperty(`--${key}`, `${value}`);
        delete props[key];
      });
      Object.keys(props).forEach((name) => node.style.removeProperty(`--${name}`));
      props = _props;
    }
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-download/use-download.js
function download(node, params) {
  const click = async () => {
    const { blob, filename } = params;
    try {
      const anchor = document.createElement("a");
      const url = URL.createObjectURL(blob);
      anchor.href = url;
      anchor.download = filename || "";
      document.body.appendChild(anchor);
      anchor.click();
      await tick();
      document.body.removeChild(anchor);
      URL.revokeObjectURL(url);
      node.dispatchEvent(new CustomEvent("usedownload", { detail: { blob, filename } }));
    } catch (e) {
      node.dispatchEvent(new CustomEvent("usedownload-error", { detail: { blob, filename } }));
    }
  };
  node.addEventListener("click", click, true);
  return {
    update: (_params) => params = _params,
    destroy: () => node.removeEventListener("click", click, true)
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-focus/use-focus.js
function focus(node) {
  node.focus();
  return;
}

// node_modules/@svelteuidev/composables/dist/actions/use-focus-trap/tabbable.js
var TABBABLE_NODES = /input|select|textarea|button|object/;
var FOCUS_SELECTOR = "a, input, select, textarea, button, object, [tabindex]";
function hidden(element) {
  if (false) {
    return false;
  }
  return element.style.display === "none";
}
function visible(element) {
  const isHidden = element.getAttribute("aria-hidden") || element.getAttribute("hidden") || element.getAttribute("type") === "hidden";
  if (isHidden) {
    return false;
  }
  let parentElement = element;
  while (parentElement) {
    if (parentElement === document.body || parentElement.nodeType === 11) {
      break;
    }
    if (hidden(parentElement)) {
      return false;
    }
    parentElement = parentElement.parentNode;
  }
  return true;
}
function getElementTabIndex(element) {
  const tabIndex = element.getAttribute("tabindex");
  return tabIndex ? parseInt(tabIndex, 10) : null;
}
function focusable(element) {
  const nodeName = element.nodeName.toLowerCase();
  const isTabIndexNotNull = getElementTabIndex(element) !== null;
  const res = (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    TABBABLE_NODES.test(nodeName) && !element.disabled || (element instanceof HTMLAnchorElement ? element.href || isTabIndexNotNull : isTabIndexNotNull)
  );
  return res && visible(element);
}
function tabbable(element) {
  const tabIndex = getElementTabIndex(element);
  const isTabIndexNull = tabIndex === null;
  return (isTabIndexNull || tabIndex >= 0) && focusable(element);
}
function findTabbableDescendants(element) {
  return Array.from(element.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);
}

// node_modules/@svelteuidev/composables/dist/actions/use-focus-trap/scope-tab.js
function scopeTab(node, event) {
  const tabbable2 = findTabbableDescendants(node);
  if (!tabbable2.length) {
    event.preventDefault();
    return;
  }
  const finalTabbable = tabbable2[event.shiftKey ? 0 : tabbable2.length - 1];
  const root = node.getRootNode();
  const leavingFinalTabbable = finalTabbable === root.activeElement || node === root.activeElement;
  if (!leavingFinalTabbable) {
    return;
  }
  event.preventDefault();
  const target = tabbable2[event.shiftKey ? tabbable2.length - 1 : 0];
  if (target) {
    target.focus();
  }
}

// node_modules/@svelteuidev/composables/dist/actions/use-focus-trap/create-aria-hider.js
function createAriaHider(containerNode) {
  const hiddenDomNodes = [];
  gatherOutsideDomNodes(containerNode);
  hiddenDomNodes.map(({ node }) => {
    node.setAttribute("aria-hidden", "true");
  });
  function gatherOutsideDomNodes(currentElement) {
    if (!currentElement) {
      return void 0;
    }
    if (currentElement !== document.querySelector("body")) {
      const parentElement = currentElement.parentElement;
      const siblingElements = [...Array.from(parentElement.children)];
      siblingElements.forEach((node) => {
        const ariaHidden = node.getAttribute("aria-hidden");
        if (node !== currentElement && node.nodeName !== "SCRIPT" && (ariaHidden === null || ariaHidden === "false")) {
          hiddenDomNodes.push({ node, ariaHidden });
        }
      });
      gatherOutsideDomNodes(parentElement);
    }
  }
  return () => {
    hiddenDomNodes.forEach((item) => {
      if (!item) {
        return;
      }
      if (item.ariaHidden === null) {
        item.node.removeAttribute("aria-hidden");
      } else {
        item.node.setAttribute("aria-hidden", item.ariaHidden);
      }
    });
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-focus-trap/use-focus-trap.js
function focustrap(node, active = true) {
  let restoreAria = null;
  const handleKeyDown = (event) => {
    if (!active) {
      return;
    }
    if (event.key === "Tab" && node) {
      scopeTab(node, event);
    }
  };
  document.addEventListener("keydown", handleKeyDown);
  activate();
  function activate() {
    if (!active) {
      if (restoreAria) {
        restoreAria();
      }
      return;
    }
    restoreAria = createAriaHider(node);
    const processNode = () => {
      let focusElement = node.querySelector("[autofocus]");
      if (!focusElement) {
        const children = Array.from(node.querySelectorAll(FOCUS_SELECTOR));
        focusElement = children.find(tabbable) || children.find(focusable) || null;
        if (!focusElement && focusable(node))
          focusElement = node;
      }
      if (focusElement) {
        focusElement.focus({ preventScroll: true });
      } else if (true) {
        console.warn("[@svelteuidev/composables/use-focus-trap] Failed to find focusable element within provided node", node);
      }
    };
    setTimeout(() => {
      if (node.getRootNode()) {
        processNode();
      } else if (true) {
        console.warn("[@svelteuidev/composables/use-focus-trap] node is not part of the dom", node);
      }
    });
  }
  return {
    update(newActive) {
      active = newActive;
      activate();
    },
    destroy() {
      document.removeEventListener("keydown", handleKeyDown);
      if (restoreAria) {
        restoreAria();
      }
    }
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-hot-key/parse-hotkey.js
function parseHotkey(hotkey2) {
  const keys = hotkey2.toLowerCase().split("+").map((part) => part.trim());
  const modifiers = {
    alt: keys.includes("alt"),
    ctrl: keys.includes("ctrl"),
    meta: keys.includes("meta"),
    mod: keys.includes("mod"),
    shift: keys.includes("shift")
  };
  const reservedKeys = ["alt", "ctrl", "meta", "shift", "mod"];
  const freeKey = keys.find((key) => !reservedKeys.includes(key));
  return {
    ...modifiers,
    key: freeKey
  };
}
function isExactHotkey(hotkey2, event) {
  const { alt, ctrl, meta, mod, shift, key } = hotkey2;
  const { altKey, ctrlKey, metaKey, shiftKey, key: pressedKey } = event;
  if (alt !== altKey) {
    return false;
  }
  if (mod) {
    if (!ctrlKey && !metaKey) {
      return false;
    }
  } else {
    if (ctrl !== ctrlKey) {
      return false;
    }
    if (meta !== metaKey) {
      return false;
    }
  }
  if (shift !== shiftKey) {
    return false;
  }
  if (key && (pressedKey.toLowerCase() === key.toLowerCase() || event.code.replace("Key", "").toLowerCase() === key.toLowerCase())) {
    return true;
  }
  return false;
}
function getHotkeyMatcher(hotkey2) {
  return (event) => isExactHotkey(parseHotkey(hotkey2), event);
}
function getHotkeyHandler(hotkeys) {
  return (event) => {
    hotkeys.forEach(([hotkey2, handler]) => {
      if (getHotkeyMatcher(hotkey2)(event)) {
        event.preventDefault();
        handler(event);
      }
    });
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-hot-key/use-hot-key.js
function shouldFireEvent(event) {
  if (event.target instanceof HTMLElement) {
    return !["INPUT", "TEXTAREA", "SELECT"].includes(event.target.tagName);
  }
}
function hotkey(node, hotkeys) {
  const keyDownListener = (event) => {
    hotkeys.forEach(([hotkey2, handler]) => {
      if (getHotkeyMatcher(hotkey2)(event) && shouldFireEvent(event)) {
        event.preventDefault();
        handler(event);
      }
    });
  };
  document.documentElement.addEventListener("keydown", keyDownListener);
  return {
    update: (updatedHotKeys) => {
      hotkeys = updatedHotKeys;
    },
    destroy: () => {
      document.documentElement.removeEventListener("keydown", keyDownListener);
    }
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-io/use-io.js
var createEvent = (name, detail) => new CustomEvent(name, { detail });
var defaultOptions = {
  root: null,
  rootMargin: "0px",
  threshold: 0,
  unobserveOnEnter: false
};
function io(node, options = {}) {
  const { root, rootMargin, threshold, unobserveOnEnter } = { ...defaultOptions, ...options };
  let prevPosition = {
    x: void 0,
    y: void 0
  };
  const scrollDirection = {
    vertical: void 0,
    horizontal: void 0
  };
  if (typeof IntersectionObserver !== "undefined" && node) {
    const observer2 = new IntersectionObserver((entries, _observer) => {
      entries.forEach((singleEntry) => {
        if (prevPosition.y > singleEntry.boundingClientRect.y) {
          scrollDirection.vertical = "up";
        } else {
          scrollDirection.vertical = "down";
        }
        if (prevPosition.x > singleEntry.boundingClientRect.x) {
          scrollDirection.horizontal = "left";
        } else {
          scrollDirection.horizontal = "right";
        }
        prevPosition = {
          y: singleEntry.boundingClientRect.y,
          x: singleEntry.boundingClientRect.x
        };
        const detail = {
          inView: singleEntry.isIntersecting,
          entry: singleEntry,
          scrollDirection,
          node,
          observer: _observer
        };
        node.dispatchEvent(createEvent("change", detail));
        if (singleEntry.isIntersecting) {
          node.dispatchEvent(createEvent("enter", detail));
          unobserveOnEnter && _observer.unobserve(node);
        } else {
          node.dispatchEvent(createEvent("leave", detail));
        }
      });
    }, {
      root,
      rootMargin,
      threshold
    });
    setTimeout(() => {
      node.dispatchEvent(createEvent("init", { observer: observer2, node }));
    }, 0);
    observer2.observe(node);
    return {
      destroy: () => {
        observer2.unobserve(node);
      }
    };
  }
}

// node_modules/@svelteuidev/composables/dist/actions/use-io/use-io.config.js
var use_io_config_exports = {};

// node_modules/@svelteuidev/composables/dist/actions/use-lazy/use-lazy.js
var nodeAttributesMap = /* @__PURE__ */ new WeakMap();
var intersection_handler = (entries) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting && entry.target instanceof HTMLElement) {
      const node = entry.target;
      Object.assign(node, nodeAttributesMap.get(node));
      lazyLoadObserver.unobserve(node);
    }
  });
};
var lazyLoadObserver;
function observer() {
  return lazyLoadObserver ?? (lazyLoadObserver = new IntersectionObserver(intersection_handler));
}
function lazy(node, attributes) {
  nodeAttributesMap.set(node, attributes);
  observer().observe(node);
  return {
    destroy() {
      observer().unobserve(node);
    }
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-lock-scroll/utils/create-style-tag.js
function createStyleTag() {
  const tag = document.createElement("style");
  tag.type = "text/css";
  tag.setAttribute("svelteui-scroll-lock", "");
  return tag;
}

// node_modules/@svelteuidev/composables/dist/actions/use-lock-scroll/utils/get-scroll-width.js
function getScrollWidth() {
  if (typeof window === "undefined" || typeof document === "undefined")
    return 0;
  const paddingRight = parseInt(window.getComputedStyle(document.body).paddingRight, 10);
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  return paddingRight + scrollbarWidth;
}

// node_modules/@svelteuidev/composables/dist/actions/use-lock-scroll/utils/get-lock-styles.js
var getLockStyles = ({ disableBodyPadding }) => {
  const scrollWidth = disableBodyPadding ? null : getScrollWidth();
  const styles = `body {
        --removed-scroll-width: ${scrollWidth}px;
        touch-action: none;
        overflow: hidden !important;
        position: relative !important;
        ${scrollWidth ? "padding-right: var(--removed-scroll-width) !important;" : ""}
        `;
  return styles;
};

// node_modules/@svelteuidev/composables/dist/actions/use-lock-scroll/utils/inject-style-tag.js
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}

// node_modules/@svelteuidev/composables/dist/actions/use-lock-scroll/utils/insert-style-tag.js
function insertStyleTag(tag) {
  const head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}

// node_modules/@svelteuidev/composables/dist/shared/actions/utils/environment.js
var isBrowser = () => typeof window !== "undefined";
var ENVIRONMENT = {
  browser: isBrowser(),
  server: !isBrowser()
};
var defaultWindow = ENVIRONMENT.browser ? window : void 0;

// node_modules/@svelteuidev/composables/dist/actions/use-lock-scroll/use-lock-scroll.js
function lockscroll(node, lock, options = { disableBodyPadding: false }) {
  const { browser: browser3 } = ENVIRONMENT;
  let window2;
  if (browser3) {
    window2 = defaultWindow;
  }
  let scrollLocked = lock ?? false;
  const { disableBodyPadding } = options;
  let stylesheet;
  const lockScroll = () => {
    const styles = getLockStyles({ disableBodyPadding });
    const sheet = createStyleTag();
    injectStyles(sheet, styles);
    insertStyleTag(sheet);
    stylesheet = sheet;
  };
  const unlockScroll = () => {
    var _a;
    if (!stylesheet)
      return;
    (_a = stylesheet == null ? void 0 : stylesheet.parentNode) == null ? void 0 : _a.removeChild(stylesheet);
    stylesheet = null;
  };
  if (scrollLocked) {
    lockScroll();
  } else {
    unlockScroll();
  }
  if (lock !== void 0) {
    scrollLocked = lock;
  }
  if (lock === void 0 && typeof window2 !== "undefined") {
    window2.document.body.style.overflow === "hidden" && (scrollLocked = lock);
  }
  return {
    update: (locked) => {
      if (locked) {
        lockScroll();
      } else {
        window2.document.body.style.overflow === "visible" && (scrollLocked = lock);
        unlockScroll();
      }
    },
    destroy: () => {
      unlockScroll();
      return;
    }
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-long-press/use-long-press.js
function longpress(node, duration) {
  let timer;
  function handlePress() {
    timer = window.setTimeout(() => {
      node.dispatchEvent(new CustomEvent("longpress"));
    }, duration);
  }
  function handleRelease() {
    clearTimeout(timer);
  }
  node.addEventListener("mousedown", handlePress);
  node.addEventListener("mouseup", handleRelease);
  node.addEventListener("touchstart", handlePress);
  node.addEventListener("touchend", handleRelease);
  return {
    update(newDuration) {
      handleRelease();
      duration = newDuration;
    },
    destroy() {
      handleRelease();
      node.removeEventListener("touchend", handleRelease);
      node.removeEventListener("touchstart", handlePress);
      node.removeEventListener("mouseup", handleRelease);
      node.removeEventListener("mousedown", handlePress);
    }
  };
}

// node_modules/@svelteuidev/composables/dist/shared/actions/utils/clamp.js
function clamp({ value, min, max }) {
  return Math.min(Math.max(value, min), max);
}

// node_modules/@svelteuidev/composables/dist/shared/utilities/utils/_configurable.js
var isBrowser2 = () => typeof window !== "undefined";
var browser = isBrowser2();
var defaultWindow2 = browser ? window : void 0;
var defaultDocument = browser ? window.document : void 0;
var defaultNavigator = browser ? window.navigator : void 0;
var defaultLocation = browser ? window.location : void 0;

// node_modules/@svelteuidev/composables/dist/shared/utilities/utils/is/is.js
var toString = Object.prototype.toString;
var isClient = typeof window !== void 0;
var isBoolean = (val) => typeof val === "boolean";
var isFunction = (val) => typeof val === "function";
var isNumber = (val) => typeof val === "number";
var isString = (val) => typeof val === "string";
var isObject = (val) => toString.call(val) === "[object Object]";
var isWindow = (val) => typeof window !== "undefined" && toString.call(val) === "[object Window]";
var now = () => Date.now();
var timestamp = () => +Date.now();
var sleep = (ms = 2e3) => new Promise((r) => setTimeout(r, ms));
var rand = (min, max) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

// node_modules/@svelteuidev/composables/dist/shared/utilities/utils/time/time.js
var dateTimeString = (timestamp2, locale = void 0, options = {
  dateStyle: "short",
  timeStyle: "short"
}) => {
  const date = new Date(timestamp2);
  return new Intl.DateTimeFormat(locale, options).format(date);
};

// node_modules/@svelteuidev/composables/dist/shared/utilities/utils/random-id/random-id.js
function randomID() {
  return `svelteui-${Math.random().toString(36).substring(2, 10)}`;
}

// node_modules/@svelteuidev/composables/dist/shared/utils/upper-first/upper-first.js
function upperFirst(value) {
  return typeof value !== "string" ? "" : value.charAt(0).toUpperCase() + value.slice(1);
}

// node_modules/@svelteuidev/composables/dist/shared/utils/filter/debounce.js
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  const filter = (invoke) => {
    const duration = ms;
    const maxDuration = options.maxWait;
    if (timer)
      clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer)
          clearTimeout(timer);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }
    timer = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };
  return filter;
}

// node_modules/@svelteuidev/composables/dist/shared/utils/filter/filter.js
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    filter(() => fn.apply(this, args), { fn, thisArg: this, args });
  }
  return wrapper;
}

// node_modules/@svelteuidev/composables/dist/shared/utils/filter/throttle.js
function throttleFilter(ms, trailing = true, leading = true) {
  let lastExec = 0;
  let timer;
  let isLeading = true;
  const clear = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
  };
  const filter = (invoke) => {
    const duration = ms;
    const elapsed = Date.now() - lastExec;
    clear();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke();
    }
    if (elapsed > duration && (leading || !isLeading)) {
      lastExec = Date.now();
      invoke();
    } else if (trailing) {
      timer = setTimeout(() => {
        lastExec = Date.now();
        isLeading = true;
        clear();
        invoke();
      }, duration);
    }
    if (!leading && !timer)
      timer = setTimeout(() => isLeading = true, duration);
    isLeading = false;
  };
  return filter;
}

// node_modules/@svelteuidev/composables/dist/actions/use-move/use-move.js
function move(node) {
  let moving = false;
  let active = false;
  let frame = 0;
  function bindListeners() {
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
    document.addEventListener("touchmove", onTouchMove);
    document.addEventListener("touchend", onTouchEnd);
  }
  function unbindListeners() {
    document.removeEventListener("touchend", onTouchEnd);
    document.removeEventListener("touchmove", onTouchMove);
    document.removeEventListener("mouseup", onMouseUp);
    document.removeEventListener("mousemove", onMouseMove);
  }
  function startMove() {
    if (moving)
      return;
    moving = true;
    active = true;
    node.dispatchEvent(new CustomEvent("move:start"));
    bindListeners();
  }
  function _move(x, y) {
    cancelAnimationFrame(frame);
    frame = requestAnimationFrame(() => {
      const { left, top, width, height } = node.getBoundingClientRect();
      if (!width || !height)
        return;
      node.dispatchEvent(new CustomEvent("move", {
        detail: {
          x: clamp({ value: (x - left) / width, min: 0, max: 1 }),
          y: clamp({ value: (y - top) / height, min: 0, max: 1 })
        }
      }));
    });
  }
  function stopMove() {
    if (!moving)
      return;
    moving = false;
    active = false;
    unbindListeners();
    node.dispatchEvent(new CustomEvent("move:stop"));
  }
  function onMouseDown(event) {
    startMove();
    onMouseMove(event);
  }
  function onMouseMove(event) {
    _move(event.clientX, event.clientY);
  }
  function onMouseUp() {
    stopMove();
  }
  function onTouchStart(event) {
    startMove();
    onTouchMove(event);
  }
  function onTouchMove(event) {
    _move(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
  }
  function onTouchEnd() {
    stopMove();
  }
  node.addEventListener("mousedown", onMouseDown);
  node.addEventListener("touchstart", onTouchStart);
  return {
    destroy() {
      unbindListeners();
      node.removeEventListener("touchstart", onTouchStart);
      node.removeEventListener("mousedown", onMouseDown);
    }
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-page-leave/use-page-leave.js
function pageleave(node, callback) {
  document.documentElement.addEventListener("mouseleave", callback);
  return {
    destroy() {
      document.documentElement.removeEventListener("mouseleave", callback);
    }
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-persistent-tab/use-persistent-tab.js
function persistenttab(node, enabled) {
  function handler(e) {
    e.preventDefault();
    e.returnValue = "";
  }
  function setHandler(prevent) {
    (prevent ? window.addEventListener : window.removeEventListener)("beforeunload", handler);
  }
  setHandler(enabled);
  return {
    update: setHandler,
    destroy() {
      setHandler(false);
    }
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-portal/use-portal.js
function portal(node, target = "body") {
  let targetNode;
  async function update(newTarget) {
    target = newTarget;
    if (typeof target === "string") {
      targetNode = document.querySelector(target);
      if (targetNode === null) {
        await tick();
        targetNode = document.querySelector(target);
      }
      if (targetNode === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement) {
      targetNode = target;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    targetNode.appendChild(node);
    node.hidden = false;
  }
  function destroy() {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  update(target);
  return {
    update,
    destroy
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-tab-leave/use-tab-leave.js
function tableave(node, callback) {
  document.addEventListener("visibilitychange", callback);
  return {
    destroy() {
      document.removeEventListener("visibilitychange", callback);
    }
  };
}

// node_modules/@svelteuidev/composables/dist/utilities/use-browser-context/use-browser-context.js
var listenerOptions = {
  passive: true
};
function useBrowserContext() {
  let window2;
  if (browser)
    window2 = defaultWindow2;
  const setState = (trigger) => {
    const { state: state2, length } = (window2 == null ? void 0 : window2.history) ?? {};
    const { hash, host, hostname, href, origin, pathname, port, protocol, search } = (window2 == null ? void 0 : window2.location) ?? {};
    return {
      trigger,
      state: state2,
      length,
      hash,
      host,
      hostname,
      href,
      origin,
      pathname,
      port,
      protocol,
      search
    };
  };
  const state = writable(setState("load"));
  onMount(() => {
    window2.addEventListener("popstate", () => state.set(setState("popstate")), listenerOptions);
    window2.addEventListener("hashchange", () => state.set(setState("hashchange")), listenerOptions);
    return () => {
      window2.removeEventListener("popstate", () => state.set(setState("popstate")));
      window2.removeEventListener("hashchange", () => state.set(setState("hashchange")));
    };
  });
  return state;
}

// node_modules/@svelteuidev/composables/dist/utilities/use-debounce/use-debounce.js
function useDebounce(fn, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn);
}

// node_modules/@svelteuidev/composables/dist/utilities/use-eye-dropper/use-eye-dropper.js
function useEyeDropper(options = {}) {
  let window2;
  if (browser)
    window2 = defaultWindow2;
  const { initialValue = "" } = options;
  const isSupported = Boolean(typeof window2 !== "undefined" && "EyeDropper" in window2);
  const sRGBHex = writable(initialValue);
  async function open(openOptions) {
    if (!isSupported)
      return;
    const eyeDropper = new window2.EyeDropper();
    const res = await eyeDropper.open(openOptions);
    sRGBHex.set(res.sRGBHex);
    return res;
  }
  return {
    isSupported,
    sRGBHex,
    open
  };
}

// node_modules/@svelteuidev/composables/dist/utilities/use-focus-return/use-focus-return.js
function useFocusReturn() {
  let lastActiveElement;
  const returnFocus = () => {
    if (lastActiveElement && "focus" in lastActiveElement && typeof lastActiveElement.focus === "function") {
      lastActiveElement.focus({ preventScroll: true });
    }
  };
  return {
    handleFocusReturn(opened, shouldReturnFocus = true) {
      if (opened) {
        lastActiveElement = document.activeElement;
      } else if (shouldReturnFocus) {
        returnFocus();
      }
    },
    returnFocus
  };
}

// node_modules/@svelteuidev/composables/dist/utilities/use-focus-within/use-focus-within.js
function containsRelatedTarget(event) {
  if (event.currentTarget instanceof HTMLElement && event.relatedTarget instanceof HTMLElement) {
    return event.currentTarget.contains(event.relatedTarget);
  }
  return false;
}
function useFocusWithin({ onBlur, onFocus } = {}) {
  const focused = writable(false);
  let focusedRef = false;
  const setFocused = (value) => {
    focused.set(value);
    focusedRef = value;
  };
  const handleFocusIn = (event) => {
    if (!focusedRef) {
      setFocused(true);
      onFocus == null ? void 0 : onFocus(event);
    }
  };
  const handleFocusOut = (event) => {
    if (focusedRef && !containsRelatedTarget(event)) {
      setFocused(false);
      onBlur == null ? void 0 : onBlur(event);
    }
  };
  const focuswithin = (node) => {
    node == null ? void 0 : node.addEventListener("focusin", handleFocusIn);
    node == null ? void 0 : node.addEventListener("focusout", handleFocusOut);
    return {
      destroy: () => {
        node == null ? void 0 : node.removeEventListener("focusin", handleFocusIn);
        node == null ? void 0 : node.removeEventListener("focusout", handleFocusOut);
      }
    };
  };
  return [focused, focuswithin];
}

// node_modules/@svelteuidev/composables/dist/utilities/use-hash/use-hash.js
function useHash(prefix = "svelteui", persist = false) {
  if (persist && browser) {
    let hash = `${prefix}-${Math.random().toString(36).substring(2, 10)}`;
    if (localStorage[`${prefix}-hash`] !== void 0) {
      hash = localStorage.getItem(`${prefix}-hash`);
    } else {
      localStorage.setItem(`${prefix}-hash`, hash);
    }
    return hash;
  }
  return `${prefix}-${Math.random().toString(36).substring(2, 10)}`;
}

// node_modules/@svelteuidev/composables/dist/utilities/use-id/use-id.js
var IDX = 256;
var BUFFER;
var HEX = [];
while (IDX--)
  HEX[IDX] = (IDX + 256).toString(16).substring(1);
function useId() {
  let i = 0, num, out = "";
  if (!BUFFER || IDX + 16 > 256) {
    BUFFER = Array(i = 256);
    while (i--)
      BUFFER[i] = 256 * Math.random() | 0;
    i = IDX = 0;
  }
  for (; i < 16; i++) {
    num = BUFFER[IDX + i];
    if (i == 6)
      out += HEX[num & 15 | 64];
    else if (i == 8)
      out += HEX[num & 63 | 128];
    else
      out += HEX[num];
    if (i & 1 && i > 1 && i < 11)
      out += "-";
  }
  IDX++;
  return out;
}

// node_modules/@svelteuidev/composables/dist/utilities/use-mouse-position/use-mouse-position.js
function useMousePosition(append = false) {
  const position = writable({ x: 0, y: 0 });
  const setMousePosition = (event) => {
    if (append === false) {
      const target = event.currentTarget;
      const rect = target.getBoundingClientRect();
      const x = Math.max(0, Math.round(event.pageX - rect.left - (window.pageXOffset || window.scrollX)));
      const y = Math.max(0, Math.round(event.pageY - rect.top - (window.pageYOffset || window.scrollY)));
      position.set({ x, y });
    } else {
      position.set({ x: event.clientX, y: event.clientY });
    }
  };
  const mouseposition = (node) => {
    const element = !append ? node : document;
    element.addEventListener("mousemove", setMousePosition);
    return {
      destroy: () => {
        element.removeEventListener("mousemove", setMousePosition);
      }
    };
  };
  return [position, mouseposition];
}

// node_modules/@svelteuidev/composables/dist/utilities/use-os/use-os.js
function getOS() {
  const { userAgent } = window.navigator;
  const { platform } = window.navigator;
  const macosPlatforms = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"];
  const windowsPlatforms = ["Win32", "Win64", "Windows", "WinCE"];
  const iosPlatforms = ["iPhone", "iPad", "iPod"];
  let os = "undetermined";
  if (macosPlatforms.indexOf(platform) !== -1) {
    os = "macos";
  } else if (iosPlatforms.indexOf(platform) !== -1) {
    os = "ios";
  } else if (windowsPlatforms.indexOf(platform) !== -1) {
    os = "windows";
  } else if (/iPhone|iPad|iPod/i.test(userAgent)) {
    os = "ios";
  } else if (/Win/i.test(userAgent)) {
    os = "windows";
  } else if (/Android/i.test(userAgent)) {
    os = "android";
  } else if (/Mac/i.test(userAgent)) {
    os = "macos";
  } else if (/Linux/i.test(userAgent)) {
    os = "linux";
  }
  return os;
}
function useOs() {
  if (typeof window !== "undefined") {
    return getOS();
  }
  return "undetermined";
}

// node_modules/@svelteuidev/composables/dist/utilities/use-raf-fn/use-raf-fn.js
var isBrowser3 = () => typeof window !== "undefined";
var browser2 = isBrowser3();
function useRafFn(fn, options = {}) {
  const { immediate = true } = options;
  let isActive = false;
  async function loop() {
    if (!isActive)
      return;
    try {
      fn();
      if (browser2)
        await window.requestAnimationFrame(loop);
    } catch (err) {
      console.error(err);
    }
  }
  function resume() {
    if (!isActive) {
      isActive = true;
      loop();
    }
  }
  function pause() {
    isActive = false;
  }
  if (immediate)
    resume();
  return {
    isActive,
    pause,
    resume
  };
}

// node_modules/@svelteuidev/composables/dist/utilities/use-regex/use-regex.js
var PATTERN_BANK = [{ name: "getAllOf", pattern: "(?:^|W)%svelteui%(?:$|W)" }];
var useRegexOptions = {
  test: false,
  testType: "test",
  testString: ""
};
function useRegexFactory(extensions = []) {
  const patternBank = [...PATTERN_BANK, ...extensions];
  function useRegex(name, matcher, options = useRegexOptions) {
    let pattern;
    const { test, testType, testString } = { ...useRegexOptions, ...options };
    patternBank.forEach((_pattern) => {
      if (name === _pattern.name)
        pattern = _pattern.pattern;
    });
    pattern = pattern.replace(/%svelteui%/g, matcher);
    const regex = new RegExp(pattern, testType === "match-all" ? "g" : null);
    if (test) {
      let value;
      switch (testType) {
        case "test":
          value = regex.test(testString);
          break;
        case "search":
          value = testString.search(regex);
          break;
        case "match":
          value = testString.match(regex);
          break;
        case "match-all":
          value = testString.matchAll(regex);
          break;
        default:
          break;
      }
      return value;
    }
    return regex;
  }
  return useRegex;
}

// node_modules/@svelteuidev/composables/dist/utilities/use-throttle/use-throttle.js
function useThrottle(fn, ms = 200, trailing = true, leading = true) {
  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);
}

// node_modules/@svelteuidev/composables/dist/utilities/use-viewport-size/use-viewport-size.js
var listenerOptions2 = {
  passive: true
};
function useViewportSize() {
  let window2;
  if (browser)
    window2 = defaultWindow2;
  const windowSize = writable({
    width: browser ? window2.innerWidth : 0,
    height: browser ? window2.innerHeight : 0
  });
  const setSize = () => {
    windowSize.set({
      width: window2.innerWidth || 0,
      height: window2.innerHeight || 0
    });
  };
  if (browser) {
    window2.addEventListener("resize", setSize, listenerOptions2);
    window2.addEventListener("orientationchange", setSize, listenerOptions2);
  }
  return windowSize;
}

// node_modules/@svelteuidev/composables/dist/utilities/use-web-worker/lib/jobRunner.js
var jobRunner = (userFunc) => (e) => {
  const userFuncArgs = e.data[0];
  return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {
    postMessage(["SUCCESS", result]);
  }).catch((error) => {
    postMessage(["ERROR", error]);
  });
};
var jobRunner_default = jobRunner;

// node_modules/@svelteuidev/composables/dist/utilities/use-web-worker/lib/depsParser.js
var depsParser = (deps) => {
  if (deps.length === 0)
    return "";
  const depsString = deps.map((dep) => `'${dep}'`).toString();
  return `importScripts(${depsString})`;
};
var depsParser_default = depsParser;

// node_modules/@svelteuidev/composables/dist/utilities/use-web-worker/lib/createWorkerBlobUrl.js
var createWorkerBlobUrl = (fn, deps) => {
  const blobCode = `${depsParser_default(deps)}; onmessage=(${jobRunner_default})(${fn})`;
  const blob = new Blob([blobCode], { type: "text/javascript" });
  const url = URL.createObjectURL(blob);
  return url;
};
var createWorkerBlobUrl_default = createWorkerBlobUrl;

// node_modules/@svelteuidev/composables/dist/utilities/use-web-worker/use-web-worker.js
var useWebWorker = (fn, options = {}) => {
  const { dependencies = [], timeout, window: window2 = defaultWindow2 } = options;
  let timeoutId, worker;
  let workerStatus = "PENDING";
  let promise = {};
  const workerTerminate = (status = "PENDING") => {
    if (worker && worker._url && window2) {
      worker.terminate();
      URL.revokeObjectURL(worker._url);
      promise = {};
      worker = void 0;
      window2.clearTimeout(timeoutId);
      workerStatus = status;
    }
  };
  workerTerminate();
  const generateWorker = () => {
    const blobUrl = createWorkerBlobUrl_default(fn, dependencies);
    const newWorker = new Worker(blobUrl);
    newWorker._url = blobUrl;
    newWorker.onmessage = (e) => {
      const { resolve = () => {
      }, reject = () => {
      } } = promise;
      const [status, result] = e.data;
      switch (status) {
        case "SUCCESS":
          resolve(result);
          workerTerminate(status);
          break;
        default:
          reject(result);
          workerTerminate("ERROR");
          break;
      }
    };
    newWorker.onerror = (e) => {
      const { reject = () => {
      } } = promise;
      reject(e);
      workerTerminate("ERROR");
    };
    if (timeout) {
      timeoutId = setTimeout(() => workerTerminate("TIMEOUT_EXPIRED"), timeout);
    }
    return newWorker;
  };
  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {
    promise = {
      resolve,
      reject
    };
    worker && worker.postMessage([[...fnArgs]]);
    workerStatus = "RUNNING";
  });
  const workerFn = (...fnArgs) => {
    if (workerStatus === "RUNNING") {
      console.error("[useWebWorker] You can only run one instance of the worker at a time.");
      return Promise.reject();
    }
    worker = generateWorker();
    return callWorker(...fnArgs);
  };
  return {
    workerFn,
    workerStatus,
    workerTerminate
  };
};

// node_modules/@svelteuidev/composables/dist/utilities/use-element-size/use-element-size.js
var defaultState = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};
function useElementSize() {
  const size = writable(defaultState);
  const elementsize = (node) => {
    let frameID = 0;
    const observer2 = browser ? new ResizeObserver((entries) => {
      const entry = entries[0];
      if (entry) {
        cancelAnimationFrame(frameID);
        frameID = requestAnimationFrame(() => {
          size.set(entry.contentRect);
        });
      }
    }) : null;
    observer2.observe(node);
    return {
      destroy: () => {
        observer2.disconnect();
        cancelAnimationFrame(frameID);
      }
    };
  };
  return [size, elementsize];
}
export {
  ENVIRONMENT,
  use_io_config_exports as IoConfig,
  browser,
  clamp,
  clickoutside,
  clipboard,
  createFilterWrapper,
  cssvariable,
  dateTimeString,
  debounceFilter,
  defaultDocument,
  defaultLocation,
  defaultNavigator,
  defaultWindow2 as defaultWindow,
  download,
  focus,
  focustrap,
  getHotkeyHandler,
  hotkey,
  io,
  isBoolean,
  isClient,
  isFunction,
  isNumber,
  isObject,
  isString,
  isWindow,
  lazy,
  lockscroll,
  longpress,
  move,
  now,
  pageleave,
  persistenttab,
  portal,
  rand,
  randomID,
  sleep,
  tableave,
  throttleFilter,
  timestamp,
  upperFirst,
  useBrowserContext,
  useDebounce,
  useElementSize,
  useEyeDropper,
  useFocusReturn,
  useFocusWithin,
  useHash,
  useId,
  useMousePosition,
  useOs,
  useRafFn,
  useRegexFactory,
  useThrottle,
  useViewportSize,
  useWebWorker
};
//# sourceMappingURL=@svelteuidev_composables.js.map
