import "./chunk-DKNDEOWF.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_element,
  claim_space,
  createEventDispatcher,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  safe_not_equal,
  space,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots
} from "./chunk-YHIUKQUI.js";
import "./chunk-5UFCALFR.js";
import "./chunk-2B2CG5KL.js";

// node_modules/svelte-tiny-virtual-list/src/constants.js
var ALIGNMENT = {
  AUTO: "auto",
  START: "start",
  CENTER: "center",
  END: "end"
};
var DIRECTION = {
  HORIZONTAL: "horizontal",
  VERTICAL: "vertical"
};
var SCROLL_CHANGE_REASON = {
  OBSERVED: 0,
  REQUESTED: 1
};
var SCROLL_PROP = {
  [DIRECTION.VERTICAL]: "top",
  [DIRECTION.HORIZONTAL]: "left"
};
var SCROLL_PROP_LEGACY = {
  [DIRECTION.VERTICAL]: "scrollTop",
  [DIRECTION.HORIZONTAL]: "scrollLeft"
};

// node_modules/svelte-tiny-virtual-list/src/SizeAndPositionManager.js
var SizeAndPositionManager = class {
  /**
   * @param {Options} options
   */
  constructor({ itemSize, itemCount, estimatedItemSize }) {
    this.itemSize = itemSize;
    this.itemCount = itemCount;
    this.estimatedItemSize = estimatedItemSize;
    this.itemSizeAndPositionData = {};
    this.lastMeasuredIndex = -1;
    this.checkForMismatchItemSizeAndItemCount();
    if (!this.justInTime)
      this.computeTotalSizeAndPositionData();
  }
  get justInTime() {
    return typeof this.itemSize === "function";
  }
  /**
   * @param {Options} options
   */
  updateConfig({ itemSize, itemCount, estimatedItemSize }) {
    if (itemCount != null) {
      this.itemCount = itemCount;
    }
    if (estimatedItemSize != null) {
      this.estimatedItemSize = estimatedItemSize;
    }
    if (itemSize != null) {
      this.itemSize = itemSize;
    }
    this.checkForMismatchItemSizeAndItemCount();
    if (this.justInTime && this.totalSize != null) {
      this.totalSize = void 0;
    } else {
      this.computeTotalSizeAndPositionData();
    }
  }
  checkForMismatchItemSizeAndItemCount() {
    if (Array.isArray(this.itemSize) && this.itemSize.length < this.itemCount) {
      throw Error(
        `When itemSize is an array, itemSize.length can't be smaller than itemCount`
      );
    }
  }
  /**
   * @param {number} index
   */
  getSize(index) {
    const { itemSize } = this;
    if (typeof itemSize === "function") {
      return itemSize(index);
    }
    return Array.isArray(itemSize) ? itemSize[index] : itemSize;
  }
  /**
   * Compute the totalSize and itemSizeAndPositionData at the start,
   * only when itemSize is a number or an array.
   */
  computeTotalSizeAndPositionData() {
    let totalSize = 0;
    for (let i = 0; i < this.itemCount; i++) {
      const size = this.getSize(i);
      const offset = totalSize;
      totalSize += size;
      this.itemSizeAndPositionData[i] = {
        offset,
        size
      };
    }
    this.totalSize = totalSize;
  }
  getLastMeasuredIndex() {
    return this.lastMeasuredIndex;
  }
  /**
   * This method returns the size and position for the item at the specified index.
   *
   * @param {number} index
   */
  getSizeAndPositionForIndex(index) {
    if (index < 0 || index >= this.itemCount) {
      throw Error(
        `Requested index ${index} is outside of range 0..${this.itemCount}`
      );
    }
    return this.justInTime ? this.getJustInTimeSizeAndPositionForIndex(index) : this.itemSizeAndPositionData[index];
  }
  /**
   * This is used when itemSize is a function.
   * just-in-time calculates (or used cached values) for items leading up to the index.
   *
   * @param {number} index
   */
  getJustInTimeSizeAndPositionForIndex(index) {
    if (index > this.lastMeasuredIndex) {
      const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();
      let offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;
      for (let i = this.lastMeasuredIndex + 1; i <= index; i++) {
        const size = this.getSize(i);
        if (size == null || isNaN(size)) {
          throw Error(`Invalid size returned for index ${i} of value ${size}`);
        }
        this.itemSizeAndPositionData[i] = {
          offset,
          size
        };
        offset += size;
      }
      this.lastMeasuredIndex = index;
    }
    return this.itemSizeAndPositionData[index];
  }
  getSizeAndPositionOfLastMeasuredItem() {
    return this.lastMeasuredIndex >= 0 ? this.itemSizeAndPositionData[this.lastMeasuredIndex] : { offset: 0, size: 0 };
  }
  /**
   * Total size of all items being measured.
   *
   * @return {number}
   */
  getTotalSize() {
    if (this.totalSize)
      return this.totalSize;
    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();
    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize;
  }
  /**
   * Determines a new offset that ensures a certain item is visible, given the alignment.
   *
   * @param {'auto' | 'start' | 'center' | 'end'} align Desired alignment within container
   * @param {number | undefined} containerSize Size (width or height) of the container viewport
   * @param {number | undefined} currentOffset
   * @param {number | undefined} targetIndex
   * @return {number} Offset to use to ensure the specified item is visible
   */
  getUpdatedOffsetForIndex({ align = ALIGNMENT.START, containerSize, currentOffset, targetIndex }) {
    if (containerSize <= 0) {
      return 0;
    }
    const datum = this.getSizeAndPositionForIndex(targetIndex);
    const maxOffset = datum.offset;
    const minOffset = maxOffset - containerSize + datum.size;
    let idealOffset;
    switch (align) {
      case ALIGNMENT.END:
        idealOffset = minOffset;
        break;
      case ALIGNMENT.CENTER:
        idealOffset = maxOffset - (containerSize - datum.size) / 2;
        break;
      case ALIGNMENT.START:
        idealOffset = maxOffset;
        break;
      default:
        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));
    }
    const totalSize = this.getTotalSize();
    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));
  }
  /**
   * @param {number} containerSize
   * @param {number} offset
   * @param {number} overscanCount
   * @return {{stop: number|undefined, start: number|undefined}}
   */
  getVisibleRange({ containerSize = 0, offset, overscanCount }) {
    const totalSize = this.getTotalSize();
    if (totalSize === 0) {
      return {};
    }
    const maxOffset = offset + containerSize;
    let start = this.findNearestItem(offset);
    if (start === void 0) {
      throw Error(`Invalid offset ${offset} specified`);
    }
    const datum = this.getSizeAndPositionForIndex(start);
    offset = datum.offset + datum.size;
    let stop = start;
    while (offset < maxOffset && stop < this.itemCount - 1) {
      stop++;
      offset += this.getSizeAndPositionForIndex(stop).size;
    }
    if (overscanCount) {
      start = Math.max(0, start - overscanCount);
      stop = Math.min(stop + overscanCount, this.itemCount - 1);
    }
    return {
      start,
      stop
    };
  }
  /**
   * Clear all cached values for items after the specified index.
   * This method should be called for any item that has changed its size.
   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.
   *
   * @param {number} index
   */
  resetItem(index) {
    this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);
  }
  /**
   * Searches for the item (index) nearest the specified offset.
   *
   * If no exact match is found the next lowest item index will be returned.
   * This allows partially visible items (with offsets just before/above the fold) to be visible.
   *
   * @param {number} offset
   */
  findNearestItem(offset) {
    if (isNaN(offset)) {
      throw Error(`Invalid offset ${offset} specified`);
    }
    offset = Math.max(0, offset);
    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();
    const lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);
    if (lastMeasuredSizeAndPosition.offset >= offset) {
      return this.binarySearch({
        high: lastMeasuredIndex,
        low: 0,
        offset
      });
    } else {
      return this.exponentialSearch({
        index: lastMeasuredIndex,
        offset
      });
    }
  }
  /**
   * @private
   * @param {number} low
   * @param {number} high
   * @param {number} offset
   */
  binarySearch({ low, high, offset }) {
    let middle = 0;
    let currentOffset = 0;
    while (low <= high) {
      middle = low + Math.floor((high - low) / 2);
      currentOffset = this.getSizeAndPositionForIndex(middle).offset;
      if (currentOffset === offset) {
        return middle;
      } else if (currentOffset < offset) {
        low = middle + 1;
      } else if (currentOffset > offset) {
        high = middle - 1;
      }
    }
    if (low > 0) {
      return low - 1;
    }
    return 0;
  }
  /**
   * @private
   * @param {number} index
   * @param {number} offset
   */
  exponentialSearch({ index, offset }) {
    let interval = 1;
    while (index < this.itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {
      index += interval;
      interval *= 2;
    }
    return this.binarySearch({
      high: Math.min(index, this.itemCount - 1),
      low: Math.floor(index / 2),
      offset
    });
  }
};

// node_modules/svelte-tiny-virtual-list/src/VirtualList.svelte
var { Object: Object_1 } = globals;
var file = "node_modules/svelte-tiny-virtual-list/src/VirtualList.svelte";
function add_css(target) {
  append_styles(target, "svelte-dwpad5", ".virtual-list-wrapper.svelte-dwpad5{overflow:auto;will-change:transform;-webkit-overflow-scrolling:touch}.virtual-list-inner.svelte-dwpad5{position:relative;display:flex;width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlydHVhbExpc3Quc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW1WQyxtQ0FBc0IsQ0FDckIsUUFBUSxDQUFvQixJQUFJLENBQ2hDLFdBQVcsQ0FBaUIsU0FBUyxDQUNyQywwQkFBMEIsQ0FBRSxLQUM3QixDQUVBLGlDQUFvQixDQUNuQixRQUFRLENBQUksUUFBUSxDQUNwQixPQUFPLENBQUssSUFBSSxDQUNoQixLQUFLLENBQU8sSUFDYiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJWaXJ0dWFsTGlzdC5zdmVsdGUiXX0= */");
}
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i];
  return child_ctx;
}
var get_item_slot_changes = (dirty) => ({
  style: dirty[0] & /*items*/
  4,
  index: dirty[0] & /*items*/
  4
});
var get_item_slot_context = (ctx) => ({
  style: (
    /*item*/
    ctx[37].style
  ),
  index: (
    /*item*/
    ctx[37].index
  )
});
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_each_block(key_1, ctx) {
  let first;
  let current;
  const item_slot_template = (
    /*#slots*/
    ctx[21].item
  );
  const item_slot = create_slot(
    item_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_item_slot_context
  );
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (item_slot)
        item_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if (item_slot)
        item_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if (item_slot) {
        item_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (item_slot) {
        if (item_slot.p && (!current || dirty[0] & /*$$scope, items*/
        1048580)) {
          update_slot_base(
            item_slot,
            item_slot_template,
            ctx,
            /*$$scope*/
            ctx[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[20]
            ) : get_slot_changes(
              item_slot_template,
              /*$$scope*/
              ctx[20],
              dirty,
              get_item_slot_changes
            ),
            get_item_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(item_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(item_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      if (item_slot)
        item_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(331:2) {#each items as item (getKey ? getKey(item.index) : item.index)}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div1;
  let t0;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[21].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_header_slot_context
  );
  let each_value = ensure_array_like_dev(
    /*items*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*getKey*/
    ctx2[0] ? (
      /*getKey*/
      ctx2[0](
        /*item*/
        ctx2[37].index
      )
    ) : (
      /*item*/
      ctx2[37].index
    )
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const footer_slot_template = (
    /*#slots*/
    ctx[21].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_footer_slot_context
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (header_slot)
        header_slot.c();
      t0 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      if (header_slot)
        header_slot.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (footer_slot)
        footer_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "virtual-list-inner svelte-dwpad5");
      attr_dev(
        div0,
        "style",
        /*innerStyle*/
        ctx[4]
      );
      add_location(div0, file, 329, 1, 7514);
      attr_dev(div1, "class", "virtual-list-wrapper svelte-dwpad5");
      attr_dev(
        div1,
        "style",
        /*wrapperStyle*/
        ctx[3]
      );
      add_location(div1, file, 326, 0, 7412);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (header_slot) {
        header_slot.m(div1, null);
      }
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append_hydration_dev(div1, t1);
      if (footer_slot) {
        footer_slot.m(div1, null);
      }
      ctx[22](div1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
      if (dirty[0] & /*$$scope, items, getKey*/
      1048581) {
        each_value = ensure_array_like_dev(
          /*items*/
          ctx2[2]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      if (!current || dirty[0] & /*innerStyle*/
      16) {
        attr_dev(
          div0,
          "style",
          /*innerStyle*/
          ctx2[4]
        );
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*wrapperStyle*/
      8) {
        attr_dev(
          div1,
          "style",
          /*wrapperStyle*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (header_slot)
        header_slot.d(detaching);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (footer_slot)
        footer_slot.d(detaching);
      ctx[22](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var thirdEventArg = (() => {
  let result = false;
  try {
    const arg = Object.defineProperty({}, "passive", {
      get() {
        result = { passive: true };
        return true;
      }
    });
    window.addEventListener("testpassive", arg, arg);
    window.remove("testpassive", arg, arg);
  } catch (e) {
  }
  return result;
})();
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VirtualList", slots, ["header", "item", "footer"]);
  let { height } = $$props;
  let { width = "100%" } = $$props;
  let { itemCount } = $$props;
  let { itemSize } = $$props;
  let { estimatedItemSize = null } = $$props;
  let { stickyIndices = null } = $$props;
  let { getKey = null } = $$props;
  let { scrollDirection = DIRECTION.VERTICAL } = $$props;
  let { scrollOffset = null } = $$props;
  let { scrollToIndex = null } = $$props;
  let { scrollToAlignment = null } = $$props;
  let { scrollToBehaviour = "instant" } = $$props;
  let { overscanCount = 3 } = $$props;
  const dispatchEvent = createEventDispatcher();
  const sizeAndPositionManager = new SizeAndPositionManager({
    itemCount,
    itemSize,
    estimatedItemSize: getEstimatedItemSize()
  });
  let mounted = false;
  let wrapper;
  let items = [];
  let state = {
    offset: scrollOffset || scrollToIndex != null && items.length && getOffsetForIndex(scrollToIndex) || 0,
    scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
  };
  let prevState = state;
  let prevProps = {
    scrollToIndex,
    scrollToAlignment,
    scrollOffset,
    itemCount,
    itemSize,
    estimatedItemSize
  };
  let styleCache = {};
  let wrapperStyle = "";
  let innerStyle = "";
  refresh();
  onMount(() => {
    $$invalidate(18, mounted = true);
    wrapper.addEventListener("scroll", handleScroll, thirdEventArg);
    if (scrollOffset != null) {
      scrollTo(scrollOffset);
    } else if (scrollToIndex != null) {
      scrollTo(getOffsetForIndex(scrollToIndex));
    }
  });
  onDestroy(() => {
    if (mounted)
      wrapper.removeEventListener("scroll", handleScroll);
  });
  function propsUpdated() {
    if (!mounted)
      return;
    const scrollPropsHaveChanged = prevProps.scrollToIndex !== scrollToIndex || prevProps.scrollToAlignment !== scrollToAlignment;
    const itemPropsHaveChanged = prevProps.itemCount !== itemCount || prevProps.itemSize !== itemSize || prevProps.estimatedItemSize !== estimatedItemSize;
    if (itemPropsHaveChanged) {
      sizeAndPositionManager.updateConfig({
        itemSize,
        itemCount,
        estimatedItemSize: getEstimatedItemSize()
      });
      recomputeSizes();
    }
    if (prevProps.scrollOffset !== scrollOffset) {
      $$invalidate(19, state = {
        offset: scrollOffset || 0,
        scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
      });
    } else if (typeof scrollToIndex === "number" && (scrollPropsHaveChanged || itemPropsHaveChanged)) {
      $$invalidate(19, state = {
        offset: getOffsetForIndex(scrollToIndex, scrollToAlignment, itemCount),
        scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
      });
    }
    prevProps = {
      scrollToIndex,
      scrollToAlignment,
      scrollOffset,
      itemCount,
      itemSize,
      estimatedItemSize
    };
  }
  function stateUpdated() {
    if (!mounted)
      return;
    const { offset, scrollChangeReason } = state;
    if (prevState.offset !== offset || prevState.scrollChangeReason !== scrollChangeReason) {
      refresh();
    }
    if (prevState.offset !== offset && scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {
      scrollTo(offset);
    }
    prevState = state;
  }
  function refresh() {
    const { offset } = state;
    const { start, stop } = sizeAndPositionManager.getVisibleRange({
      containerSize: scrollDirection === DIRECTION.VERTICAL ? height : width,
      offset,
      overscanCount
    });
    let updatedItems = [];
    const totalSize = sizeAndPositionManager.getTotalSize();
    if (scrollDirection === DIRECTION.VERTICAL) {
      $$invalidate(3, wrapperStyle = `height:${height}px;width:${width};`);
      $$invalidate(4, innerStyle = `flex-direction:column;height:${totalSize}px;`);
    } else {
      $$invalidate(3, wrapperStyle = `height:${height};width:${width}px`);
      $$invalidate(4, innerStyle = `min-height:100%;width:${totalSize}px;`);
    }
    const hasStickyIndices = stickyIndices != null && stickyIndices.length !== 0;
    if (hasStickyIndices) {
      for (let i = 0; i < stickyIndices.length; i++) {
        const index = stickyIndices[i];
        updatedItems.push({ index, style: getStyle(index, true) });
      }
    }
    if (start !== void 0 && stop !== void 0) {
      for (let index = start; index <= stop; index++) {
        if (hasStickyIndices && stickyIndices.includes(index)) {
          continue;
        }
        updatedItems.push({ index, style: getStyle(index, false) });
      }
      dispatchEvent("itemsUpdated", { start, end: stop });
    }
    $$invalidate(2, items = updatedItems);
  }
  function scrollTo(value) {
    if ("scroll" in wrapper) {
      wrapper.scroll({
        [SCROLL_PROP[scrollDirection]]: value,
        behavior: scrollToBehaviour
      });
    } else {
      $$invalidate(1, wrapper[SCROLL_PROP_LEGACY[scrollDirection]] = value, wrapper);
    }
  }
  function recomputeSizes(startIndex = 0) {
    styleCache = {};
    sizeAndPositionManager.resetItem(startIndex);
    refresh();
  }
  function getOffsetForIndex(index, align = scrollToAlignment, _itemCount = itemCount) {
    if (index < 0 || index >= _itemCount) {
      index = 0;
    }
    return sizeAndPositionManager.getUpdatedOffsetForIndex({
      align,
      containerSize: scrollDirection === DIRECTION.VERTICAL ? height : width,
      currentOffset: state.offset || 0,
      targetIndex: index
    });
  }
  function handleScroll(event) {
    const offset = getWrapperOffset();
    if (offset < 0 || state.offset === offset || event.target !== wrapper)
      return;
    $$invalidate(19, state = {
      offset,
      scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED
    });
    dispatchEvent("afterScroll", { offset, event });
  }
  function getWrapperOffset() {
    return wrapper[SCROLL_PROP_LEGACY[scrollDirection]];
  }
  function getEstimatedItemSize() {
    return estimatedItemSize || typeof itemSize === "number" && itemSize || 50;
  }
  function getStyle(index, sticky) {
    if (styleCache[index])
      return styleCache[index];
    const { size, offset } = sizeAndPositionManager.getSizeAndPositionForIndex(index);
    let style;
    if (scrollDirection === DIRECTION.VERTICAL) {
      style = `left:0;width:100%;height:${size}px;`;
      if (sticky) {
        style += `position:sticky;flex-grow:0;z-index:1;top:0;margin-top:${offset}px;margin-bottom:${-(offset + size)}px;`;
      } else {
        style += `position:absolute;top:${offset}px;`;
      }
    } else {
      style = `top:0;width:${size}px;`;
      if (sticky) {
        style += `position:sticky;z-index:1;left:0;margin-left:${offset}px;margin-right:${-(offset + size)}px;`;
      } else {
        style += `position:absolute;height:100%;left:${offset}px;`;
      }
    }
    return styleCache[index] = style;
  }
  $$self.$$.on_mount.push(function() {
    if (height === void 0 && !("height" in $$props || $$self.$$.bound[$$self.$$.props["height"]])) {
      console.warn("<VirtualList> was created without expected prop 'height'");
    }
    if (itemCount === void 0 && !("itemCount" in $$props || $$self.$$.bound[$$self.$$.props["itemCount"]])) {
      console.warn("<VirtualList> was created without expected prop 'itemCount'");
    }
    if (itemSize === void 0 && !("itemSize" in $$props || $$self.$$.bound[$$self.$$.props["itemSize"]])) {
      console.warn("<VirtualList> was created without expected prop 'itemSize'");
    }
  });
  const writable_props = [
    "height",
    "width",
    "itemCount",
    "itemSize",
    "estimatedItemSize",
    "stickyIndices",
    "getKey",
    "scrollDirection",
    "scrollOffset",
    "scrollToIndex",
    "scrollToAlignment",
    "scrollToBehaviour",
    "overscanCount"
  ];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VirtualList> was created with unknown prop '${key}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapper = $$value;
      $$invalidate(1, wrapper);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("height" in $$props2)
      $$invalidate(5, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(6, width = $$props2.width);
    if ("itemCount" in $$props2)
      $$invalidate(7, itemCount = $$props2.itemCount);
    if ("itemSize" in $$props2)
      $$invalidate(8, itemSize = $$props2.itemSize);
    if ("estimatedItemSize" in $$props2)
      $$invalidate(9, estimatedItemSize = $$props2.estimatedItemSize);
    if ("stickyIndices" in $$props2)
      $$invalidate(10, stickyIndices = $$props2.stickyIndices);
    if ("getKey" in $$props2)
      $$invalidate(0, getKey = $$props2.getKey);
    if ("scrollDirection" in $$props2)
      $$invalidate(11, scrollDirection = $$props2.scrollDirection);
    if ("scrollOffset" in $$props2)
      $$invalidate(12, scrollOffset = $$props2.scrollOffset);
    if ("scrollToIndex" in $$props2)
      $$invalidate(13, scrollToIndex = $$props2.scrollToIndex);
    if ("scrollToAlignment" in $$props2)
      $$invalidate(14, scrollToAlignment = $$props2.scrollToAlignment);
    if ("scrollToBehaviour" in $$props2)
      $$invalidate(15, scrollToBehaviour = $$props2.scrollToBehaviour);
    if ("overscanCount" in $$props2)
      $$invalidate(16, overscanCount = $$props2.overscanCount);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    thirdEventArg,
    onMount,
    onDestroy,
    createEventDispatcher,
    SizeAndPositionManager,
    DIRECTION,
    SCROLL_CHANGE_REASON,
    SCROLL_PROP,
    SCROLL_PROP_LEGACY,
    height,
    width,
    itemCount,
    itemSize,
    estimatedItemSize,
    stickyIndices,
    getKey,
    scrollDirection,
    scrollOffset,
    scrollToIndex,
    scrollToAlignment,
    scrollToBehaviour,
    overscanCount,
    dispatchEvent,
    sizeAndPositionManager,
    mounted,
    wrapper,
    items,
    state,
    prevState,
    prevProps,
    styleCache,
    wrapperStyle,
    innerStyle,
    propsUpdated,
    stateUpdated,
    refresh,
    scrollTo,
    recomputeSizes,
    getOffsetForIndex,
    handleScroll,
    getWrapperOffset,
    getEstimatedItemSize,
    getStyle
  });
  $$self.$inject_state = ($$props2) => {
    if ("height" in $$props2)
      $$invalidate(5, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(6, width = $$props2.width);
    if ("itemCount" in $$props2)
      $$invalidate(7, itemCount = $$props2.itemCount);
    if ("itemSize" in $$props2)
      $$invalidate(8, itemSize = $$props2.itemSize);
    if ("estimatedItemSize" in $$props2)
      $$invalidate(9, estimatedItemSize = $$props2.estimatedItemSize);
    if ("stickyIndices" in $$props2)
      $$invalidate(10, stickyIndices = $$props2.stickyIndices);
    if ("getKey" in $$props2)
      $$invalidate(0, getKey = $$props2.getKey);
    if ("scrollDirection" in $$props2)
      $$invalidate(11, scrollDirection = $$props2.scrollDirection);
    if ("scrollOffset" in $$props2)
      $$invalidate(12, scrollOffset = $$props2.scrollOffset);
    if ("scrollToIndex" in $$props2)
      $$invalidate(13, scrollToIndex = $$props2.scrollToIndex);
    if ("scrollToAlignment" in $$props2)
      $$invalidate(14, scrollToAlignment = $$props2.scrollToAlignment);
    if ("scrollToBehaviour" in $$props2)
      $$invalidate(15, scrollToBehaviour = $$props2.scrollToBehaviour);
    if ("overscanCount" in $$props2)
      $$invalidate(16, overscanCount = $$props2.overscanCount);
    if ("mounted" in $$props2)
      $$invalidate(18, mounted = $$props2.mounted);
    if ("wrapper" in $$props2)
      $$invalidate(1, wrapper = $$props2.wrapper);
    if ("items" in $$props2)
      $$invalidate(2, items = $$props2.items);
    if ("state" in $$props2)
      $$invalidate(19, state = $$props2.state);
    if ("prevState" in $$props2)
      prevState = $$props2.prevState;
    if ("prevProps" in $$props2)
      prevProps = $$props2.prevProps;
    if ("styleCache" in $$props2)
      styleCache = $$props2.styleCache;
    if ("wrapperStyle" in $$props2)
      $$invalidate(3, wrapperStyle = $$props2.wrapperStyle);
    if ("innerStyle" in $$props2)
      $$invalidate(4, innerStyle = $$props2.innerStyle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*scrollToIndex, scrollToAlignment, scrollOffset, itemCount, itemSize, estimatedItemSize*/
    29568) {
      $: {
        scrollToIndex, scrollToAlignment, scrollOffset, itemCount, itemSize, estimatedItemSize;
        propsUpdated();
      }
    }
    if ($$self.$$.dirty[0] & /*state*/
    524288) {
      $: {
        state;
        stateUpdated();
      }
    }
    if ($$self.$$.dirty[0] & /*height, width, stickyIndices, mounted*/
    263264) {
      $: {
        height, width, stickyIndices;
        if (mounted)
          recomputeSizes(0);
      }
    }
  };
  return [
    getKey,
    wrapper,
    items,
    wrapperStyle,
    innerStyle,
    height,
    width,
    itemCount,
    itemSize,
    estimatedItemSize,
    stickyIndices,
    scrollDirection,
    scrollOffset,
    scrollToIndex,
    scrollToAlignment,
    scrollToBehaviour,
    overscanCount,
    recomputeSizes,
    mounted,
    state,
    $$scope,
    slots,
    div1_binding
  ];
}
var VirtualList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        height: 5,
        width: 6,
        itemCount: 7,
        itemSize: 8,
        estimatedItemSize: 9,
        stickyIndices: 10,
        getKey: 0,
        scrollDirection: 11,
        scrollOffset: 12,
        scrollToIndex: 13,
        scrollToAlignment: 14,
        scrollToBehaviour: 15,
        overscanCount: 16,
        recomputeSizes: 17
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VirtualList",
      options,
      id: create_fragment.name
    });
  }
  get height() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemCount() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemCount(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemSize() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemSize(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get estimatedItemSize() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set estimatedItemSize(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stickyIndices() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stickyIndices(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getKey() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getKey(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollDirection() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollDirection(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollOffset() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollOffset(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToIndex() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollToIndex(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToAlignment() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollToAlignment(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToBehaviour() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollToBehaviour(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overscanCount() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overscanCount(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get recomputeSizes() {
    return this.$$.ctx[17];
  }
  set recomputeSizes(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VirtualList_default = VirtualList;
export {
  VirtualList_default as default
};
//# sourceMappingURL=svelte-tiny-virtual-list.js.map
